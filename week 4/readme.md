# 第四周

## 题目 01- 请你说一说什么是线程和进程？

### 进程

进程又叫行程，他是一个可执行程序在运行的实例。

进程是操作系统管理资源和执行任务的最小单元，它可以拥有自己的内存空间、文件句柄、线程等。 

因此，操作系统会通过管理各个进程的资源使用情况来分配资源。	

### 线程 

线程是进程里的一个执行线索。一个进程会产生多个执行线程。

多个同进程的线程，公用进程的堆空间。每个线程有自己栈空间和程序计数器。

## 题目 02- 使用了多线程会带来什么问题呢？

### 线程安全问题

指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的公用变量，使程序功能正确完成，就像是用单线程环境操作的一样。反之就是线程不安全的。

### 原子性

一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

### 有序性

程序按照代码指令的顺序执行就是有序性。但是，编译器和处理器为了提高程序性能，会进行指令重排。

### 可见性

当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

在多核 **CPU** 中，每个核的自己的缓存，关于同一个数据的缓存内容可能不一致。

### JMM JSR-133 （java 内存模型）

定义了Java 对共享内存在多线程程序下的读写操作的行为规范。jmm 模型进行简化得到了 happens-before规则。

#### happen-before 规则

* Program Order Rule (程序次序规则)

  在一个线程内，按照程序代码顺序的前后次序执行。

* Monitor Lock Rule (管程锁定规则)

  一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

* Volatile Variable Rule (Volatile 变量规则)

  对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

* Thread Start Rule (线程启动规则)

  Thread 对象的 start () 方法先行发生于此线程的每一个动作。

* Thread Termination Rule (线程终止规则)

  线程中的所有操作都先行发生于对此线程的终止检测。

* Thread Interruption Rule (线程中断规则)

  对线程 interrupt () 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。

* Finalizer Rule (对象终结规则)

  一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize () 方法。

* Transitivity (传递性)

  如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 。



## 题目 03- 什么是死锁？如何排查死锁?

当两个以上的运算单元，双方都在等待对方停止执行，以获取系统资源，但是没有一方提前退出时，就称为死锁。

检测死锁的常用方法：

1. 分析 Jstack 线程堆栈中的 BLOCKED 锁地址是否出现上述描述的多线程互等对方持有的锁的情况
2. 使用 **Arthas** 的 `thread -b` 命令检测死锁