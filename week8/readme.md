# 第八周作业

## 题目 01- 请你说一说 MySQL 的锁机制

### 锁的划分与类型

**按锁粒度划分，mysql 数据库锁可以分为**：

* 全局锁:锁整Database，由MySQL的SQL layer层实现
  * 对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句， 已经更新操作的事务提交语句都将被阻塞。
* 表级锁:锁某Table，由MySQL的SQL layer层实现，分为以下几种：
  * 表读锁(Table Read Lock)
  * 表写锁(Table Write Lock)
  * 元数据锁(meta data lock，MDL)
  * 自增锁(AUTO-INC Locks)
* 行级锁:锁某Row的索引，也可锁定行索引之间的间隙，由存储引擎实现【InnoDB】
  * **只有通过索引条件检索的数据，** **InnoDB**才使用行级锁，否则，**InnoDB**将使用表锁!
  * **InnoDB**行锁**是通过给 索引上的**索引项加锁来实现的
  * 按照锁定范围划分：
    * 记录锁(Record Locks) —— 锁定索引中一条记录
    * 间隙锁(Gap Locks) —— 要么锁住索引记录中间的值
    * 临键锁(Next-Key Locks) —— 相当于记录锁+间隙锁
    * 插入意向锁(Insert Intention Locks) ——做 insert 操作时添加的对记录id的锁
  * 按照**功能**划分：
    * 读锁 —— 允许一个事务去读一行，阻止其他事务更新目标行数据。
    * 写锁 —— 允许获得排他锁的事务更新数据，阻止其他事务获取或修改数据。
  * 加锁的时机：
    * 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加写锁;
    * 对于普通SELECT语句，InnoDB不会加任何锁（除了**Serializable **隔离级别）
    * 事务可以通过语句手动给记录集加共享锁或排他锁
      * 读锁
        * select * from xxxx where id=4 **lock in share mode**;
      * 写锁
        * select * from xxxx where id=4 **for update**;

**按照锁的功能划分，mysql 数据库锁可以分为：**

* **共享锁 Shared Locks (S锁，也叫读锁)**
  * 加锁方式: select...lock in share mode
  * 允许其他事务也加读锁（shared）
* **排他锁Exclusive Locks(X锁，也叫写锁)**
  * 加了写锁，不允许其他事务加读写锁

### 数据库死锁

**死锁**是指**两个或两个以上的数据库事务在执行过程中，由于竞争访问相互拥有的数据资源，而造成的一种左右互搏（想想《射雕英雄传》里面的周伯通的独创功法）的阻塞现象，若无外力作用，它们都将无法推进下去**。

如果是事后， 可以通过获取 innodb 的状态日志中的死锁日志分析死锁情况。

```mysql
SHOW ENGINE INNODB STATUS;
```



### 详细说说这条 SQL 的锁定情况：`delete from tt where uid = 666`;

分几种情况来讨论：

1. uid 是主键？
2. 隔离级别是什么？
3. uid 是否是索引？
4. uid 是否是二级唯一索引？

1. 如果 uid 是主键，索引记录加行写锁，记录锁，无论是 RR，还是 RC 隔离级别。
2. 如果 uid 是二级唯一索引，走索引，辅助索引加记录写锁，对应的主键索引记录加写锁，无论是 RR，还是 RC 隔离级别。
3. 如果 uid 是二级非唯一索引，RC隔离级别，辅助索引树满足 uid = 666 的都加记录写锁，再找 id 对应的主键索引加记录写锁。
4. 如果 uid 是二级非唯一索引，RR隔离级别，辅助索引树满足 uid = 666 的都加记录写锁，然后在索引项的GAP上 加间隙锁，再找 uid 对应的主键索引加记录写锁。
5. 如果 uid 没有索引，RC隔离级别下，全表扫描，锁聚簇索引的全部记录，然后在执行层进行过滤，再释放不满足条件的记录的锁。
6. 如果 uid 没有索引，RR隔离级别下，全表扫描，锁聚簇索引的全部记录，和所有记录之间的加间隙锁。
7. 如果是 **串行化** Serializable隔离级别，和RR隔离级别的几种情况一致。



## 题目 02- 请你说一说 MySQL 的 SQL 优化

使用 explain 命令分析 sql 的执行计划。根据执行计划的结果，做相关的针对性优化。

重点关注 explain 的相关字段有：

* **type**(重要)表示表的连接类型。
  * **const** —— **唯一索引或者主键**，返回记录一定是1行记录的等值where条件时
  * **eq_ref** —— **唯一性索引扫描**，对于每个索引键，表中只有一条记录与之匹配
  * **ref** —— **非唯一性索**引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它 返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫 描的混合体。
  * **range** —— **索引范围扫描**
  *  **index** —— **全部索引扫描**，把索引从头 到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分 组的查询。
  * **all** —— 全表扫描数据文件，然后再**在****server****层进行过滤**返回符合要求的记录。
* **rows**:显示此查询一共扫描了多少行，这个是一个估计值，不是精确的值。
* **Extra**:额外信息
  * **Using filesort** —— 使用了文件排序，说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行 读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。这种操作需要优化sql。
  * **Using index** —— 表示相应的SELECT查询中使用到了索引，避免访问表的数据行，这种查询的效率很高!
    * 如果同时出现Using Where 索引在where之后，用作查询条件
    * 如果没有同时出现Using Where ，索引在where之前，用作查询结果读取
  * **Using where** —— 表示MySQL将对InnoDB提取的结果在SQL Layer层进行过滤，过滤条件字段无索引;
  * **Using join buffer** —— 表明使用了连接缓存，比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区 的join buffer调大一些。

一般性的索引优化的策略有：

1. **表记录很少不需创建索引** 

2. **一个表的索引个数不能过多**

3. **频繁更新的字段不建议作为索引**

4. **区分度低的字段，不建议建索引**

5. **在InnoDB存储引擎中，主键索引建议使用自增的长整型，避免使用很长的字段**

6. **不建议用无序的值作为索引** 比如 UUID

7. **尽量创建组合索引，而不是单列索引**

8. **组合索引应该把频繁用到的列、区分度高的值放在前面。频繁使用代表索引的利用率高，区分度高代表筛选粒度大，这样做可最大限度利用索引价值，缩小筛选范围**

   

